% Digest notes template for CMU Software Foundations of Security & Privacy
\documentclass[11pt]{article}

% The lecture-note style (lecnotes.sty) expects these macros.
\newcommand{\course}{15-316: Software Foundations of Security \& Privacy}
\newcommand{\lecturer}{Frank Pfenning}
\newcommand{\lecdate}{January 2026}
\newcommand{\lecnum}{D}
\newcommand{\lectitle}{Digest Notes}

% Your name (shown on the title page)
\newcommand{\studentname}{Mohamed Waiel Shikfa}

\usepackage[a4paper,margin=1in]{geometry}
\usepackage{lecnotes}
\input{lmacros}

% Override lecture-notes page style (no headers/footers)
\pagestyle{empty}

\usepackage{enumitem}

\setlength{\parindent}{0pt}
\setlength{\parskip}{0.6\baselineskip}

\newcommand{\kw}[1]{\textbf{#1}}
\newcommand{\defn}[1]{\textbf{Definition.} #1}
\newcommand{\thm}[1]{\textbf{Theorem (informal).} #1}
\newcommand{\idea}[1]{\textbf{Key idea.} #1}
\newcommand{\pitfall}[1]{\textbf{Common pitfall.} #1}
\newcommand{\q}[1]{\textbf{Check yourself.} #1}

\begin{document}

\begin{titlepage}
\thispagestyle{empty}
\centering
\vspace*{0.20\textheight}

{\LARGE Software Foundations of Security \& Privacy\\[0.5em]}
{\Huge \textbf{Digest Notes}\\[0.75em]}

{\large \studentname\\[1.25em]}

\begin{minipage}{0.85\linewidth}
\small
These notes are a condensed companion to the official course
lecture notes. Each lecture is summarized as: a goal, one-page map, core definitions,
key proof patterns/recipes, common pitfalls, and a short ``check yourself'' set.
Full rule lists and semantic definitions are collected in the appendices and
referenced from the relevant lecture.
\end{minipage}

\vfill
{\small Last updated: \today}
\end{titlepage}

% \section*{How to use this}
% \begin{itemize}[leftmargin=*]
  % \item For each lecture/reading, write: (1) the goal, (2) 5--10 core definitions, (3) 2--4 key lemmas/theorems, (4) the proof pattern, (5) 3--5 pitfalls, (6) 5--10 ``check yourself'' questions.
  % \item Prefer small ``recipes'' (how to apply a rule) over long prose.
  % \item Keep each subsection terse; move details into a final ``Appendix: Details'' if needed.
% \end{itemize}

\clearpage
\section*{Lecture 2 (Jan 11, 2026): Propositional Logic and Proof}
\kw{Goal:} Use sequent calculus to (1) precisely define validity of formulas/sequents and (2) build/check formal derivations; understand soundness/completeness/decidability via invertibility + termination.

\subsection*{One-page map}
\begin{itemize}[leftmargin=*]
  \item \kw{Objects:} propositional formulas $F$ built from variables and connectives; sequents $\Gamma \vdash \Delta$.
  \item \kw{Semantics:} $\Gamma \vdash \Delta$ is valid iff ``all $\Gamma$ true implies some $\Delta$ true''.
  \item \kw{Proof system:} right rules decompose goals; left rules decompose assumptions; identity closes branches.
  \item \kw{Meta-properties:} soundness (derivable $\Rightarrow$ valid), completeness (valid $\Rightarrow$ derivable), decidability (procedure to decide validity).
\end{itemize}

\subsection*{Core definitions}
\begin{itemize}[leftmargin=*]
  \item \defn{\emph{Formula}: built from $p$ using $\land,\lor,\rightarrow,\lnot,\top,\bot$.}
  \item \defn{\emph{Valid formula}: true under every truth assignment.}
  \item \defn{\emph{Satisfiable formula}: true under some truth assignment.}
  \item \defn{\emph{Sequent} $\Gamma \vdash \Delta$: assumptions $\Gamma$ and goals $\Delta$ (multi-succedent, disjunctive).}
  \item \defn{\emph{Valid sequent}: if all formulas in $\Gamma$ are true then at least one formula in $\Delta$ is true.}
  \item \defn{\emph{Derivation}: tree built bottom-up using inference rules; leaves typically close by identity.}
\end{itemize}

\subsection*{Key rules / theorems (high level)}
\begin{itemize}[leftmargin=*]
  \item \idea{Right/Left rules eliminate a top-level connective from a goal/assumption.}
  \item \idea{Disjunction needs multi-succedent sequents for completeness.}
  \item \thm{Soundness: if $\Gamma \vdash \Delta$ is derivable then it is valid.}
  \item \thm{Completeness + decidability: all rules are invertible and reductive, so proof search terminates and succeeds iff sequent is valid.}
\end{itemize}

\subsection*{Proof-search recipe (sequent calculus)}
\begin{itemize}[leftmargin=*]
  \item \kw{Step 1:} Apply invertible rules bottom-up whenever possible (decompose connectives).
  \item \kw{Step 2:} Stop at variable-only leaves $p_1,\dots,p_n \vdash q_1,\dots,q_m$.
  \item \kw{Step 3:} Leaf closes iff some $p_i = q_j$ (identity). Otherwise it is a countermodel seed.
\end{itemize}

\subsection*{Pitfalls}
\begin{itemize}[leftmargin=*]
  \item \pitfall{Confusing formula implication $F \rightarrow G$ with sequent entailment $F \vdash G$: they coincide in validity but are different syntactic objects.}
  \item \pitfall{Using a two-rule disjunction right-introduction ($\lor R_1/\lor R_2$) breaks completeness for classical truth-table validity. In general, avoid applying more than one rule at a time.}
\end{itemize}

\subsection*{Check yourself}
\begin{enumerate}[leftmargin=*]
  \item \q{Prove $p \lor (p \rightarrow q)$ is valid using sequent calculus.}
  \item \q{Given a failed leaf $p,q \vdash r$, what truth assignment witnesses invalidity?}
\end{enumerate}

\kw{Reference:} Full propositional sequent-calculus rules are in Appendix~\ref{app:prop-sequent}.

\clearpage
\section*{Lecture 3 (Jan 13, 2026): Dynamic Logic}
\kw{Goal:} Extend sequent reasoning to talk about programs; express safety-style properties as postconditions; derive rules for program constructs (if/assignment/sequence/while).

\subsection*{One-page map}
\begin{itemize}[leftmargin=*]
  \item \kw{New syntax:} programs $\alpha$ (assign/seq/if/while) and modalities $[\alpha]Q$ (box) and $\langle\alpha\rangle Q$ (diamond).
  \item \kw{Intuition:} $[\alpha]Q$ means ``every terminating run of $\alpha$ ends in a state satisfying $Q$''.
  \item \kw{Theme:} Rules should reduce properties of compound programs to properties of smaller programs.
\end{itemize}

\subsection*{Core definitions}
\begin{itemize}[leftmargin=*]
  \item \defn{\emph{Trace}: (possibly infinite) sequence of states/events during execution.}
  \item \defn{\emph{Safety property}: ``nothing bad happens'' (prefix-closed).}
  \item \defn{\emph{Liveness property}: ``something good eventually happens''.}
  \item \defn{\emph{Box/diamond}: $[\alpha]Q$ (all terminating runs end in $Q$) and $\langle\alpha\rangle Q$ (some terminating run ends in $Q$). Since our language has no nondeterminism, $\langle\alpha\rangle Q$ is equivalent to ``$\alpha$ terminates and $[\alpha]Q$''.}
\end{itemize}

\subsection*{Key rules (as ``recipes'')}
\begin{itemize}[leftmargin=*]
  \item \idea{\kw{If:} split on the guard.}
  \item \idea{\kw{Sequential Composition:} rewrite $[\alpha;\beta]Q$ as $[\alpha]([\beta]Q)$.}
  \item \idea{\kw{Assignment:} do \emph{not} assume $x=e$ with the same $x$ on both sides of the state change; introduce fresh $x'$ (post-state value) and substitute.}
  \item \idea{\kw{While:} unfolding is sound but not reductive; loop invariants are the scalable rule.}
\end{itemize}

\subsection*{Assignment gotcha (why freshness matters)}
\begin{itemize}[leftmargin=*]
  \item \pitfall{The tempting rule ``assume $x=e$ after $x := e$'' is \emph{unsound} because it confuses the value of $x$ \emph{before} and \emph{after} the assignment.}
  \item \kw{Lecture example:} with the unsound rule you could (wrongly) justify
    $x = 2 \vdash [x := 1]\, x = 3$ by reducing it to the premise
    $x = 2, x = 1 \vdash x = 3$, which is valid only because the antecedents are contradictory.
  \item \idea{Fix (as in the notes): introduce a fresh post-state variable $x'$ and replace the postcondition $Q(x)$ with $Q(x')$. Rule shape:}
    \\[0.25em]
    $\Gamma \vdash [x := e]Q(x), \Delta$ reduces to $\Gamma, x' = e \vdash Q(x'), \Delta$ (with $x'$ fresh).
\end{itemize}

\subsection*{Loop-invariant recipe}
\begin{itemize}[leftmargin=*]
  \item \kw{Pick an invariant $J$ and prove these sequents (turnstile, not implication):}
    \begin{itemize}[leftmargin=*]
      \item \kw{Init:} $\Gamma \vdash J$
      \item \kw{Preserved:} $J, P \vdash [\alpha]J$
      \item \kw{Post:} $J, \lnot P \vdash Q$
    \end{itemize}
  \item \kw{Important:} $\Gamma$ (facts true only initially) is intentionally dropped from the preserved/post obligations.
\end{itemize}

\subsection*{Check yourself}
\begin{enumerate}[leftmargin=*]
  \item \q{Explain why $[\alpha]Q$ is vacuously true when $\alpha$ does not terminate. What property is this capturing?}
  \item \q{For the swap program (using + and -), what must the precondition include to avoid undefined behavior in bounded-integer languages?}
\end{enumerate}

\kw{Reference:} Full dynamic-logic language summary is in Appendix~\ref{app:dl-language}, and full rule summary is in Appendix~\ref{app:dl-rules}.

\clearpage
\section*{Lecture 4 (Jan 20, 2026): Semantics of Programs}
\kw{Goal:} Pin down the meaning of expressions, programs, and formulas so rule soundness proofs become ``expand definitions and chase the quantifiers''.

\subsection*{One-page map}
\begin{itemize}[leftmargin=*]
  \item \kw{State:} $\omega(x)$ is the value of variable $x$.
  \item \kw{Expression meaning:} $\omega \lbb e\rbb \in \mathbb{Z}$.
  \item \kw{Program meaning:} relation $\omega \lbb\alpha\rbb \nu$ between pre/post states.
  \item \kw{Formula meaning:} $\omega \models P$.
  \item \kw{Reusable move:} prove equivalences (e.g. $[\alpha;\beta]Q \leftrightarrow [\alpha]([\beta]Q)$) and use them as rewrite rules.
\end{itemize}

\subsection*{Core clauses (keep only the high-yield ones)}
\begin{itemize}[leftmargin=*]
  \item \defn{Assignment updates state: $\nu = \omega[x \mapsto \omega\llbracket e\rrbracket]$.}
  \item \defn{Sequence composes via an intermediate state: $\exists\mu$.}
  \item \defn{While termination is ``there exists an $n$ iterations'' (bounded-iteration semantics).}
\end{itemize}

\subsection*{Reusable proof pattern: ``unwind definitions''}
\begin{itemize}[leftmargin=*]
  \item \kw{To show} $P \leftrightarrow Q$ is valid: fix an arbitrary state $\omega$, assume $\omega \models P$, expand definitions until you can derive $\omega \models Q$ (and vice versa).
  \item \idea{This justifies using valid equivalences as both left- and right-rules (sound + invertible).}
\end{itemize}

\subsection*{Pitfalls}
\begin{itemize}[leftmargin=*]
  \item \pitfall{Quantification over program states is subtle: naive ``substitute a constant for $x$'' can fail when $x$ is read across many loop states; semantics uses state update $\omega[x\mapsto c]$.}
\end{itemize}

\subsection*{Check yourself}
\begin{enumerate}[leftmargin=*]
  \item \q{Prove (informally, by definitions) $\models [\alpha;\beta]Q \leftrightarrow [\alpha]([\beta]Q)$.}
  \item \q{Give a simple program $\alpha$ and postcondition $Q$ where $\omega \models [\alpha]Q$ holds because $\alpha$ does not terminate.}
\end{enumerate}

\kw{Reference:} Full semantics (expressions, programs, formulas) are summarized in Appendix~\ref{app:semantics}.

\clearpage
\section*{Lecture 5 (Jan 25, 2026): Proving Safety}
\kw{Goal:} Extend dynamic logic to account for \emph{unsafe} execution (undefined-behavior-style), and learn proof patterns for showing programs avoid unsafe commands (often via invariants/guards).

\subsection*{One-page map}
\begin{itemize}[leftmargin=*]
  \item \kw{Three outcomes of running a program:} (i) a post-state $\nu$, (ii) no post-state because it \emph{diverges}, or (iii) no post-state because it goes \emph{unsafe}.
  \item \kw{Semantic hook:} introduce the unsafe judgment $\omega \lbb \alpha\rbb \lightning$.
  \item \kw{Safety as a DL formula:} to show $\alpha$ is safe under precondition $P$, prove $P \arrow [\alpha]\top$.
  \item \kw{Engineering move:} \emph{sandboxing} = instrument unsafe commands with guards so the result is provably safe.
\end{itemize}

\subsection*{Core definitions}
\begin{itemize}[leftmargin=*]
  \item \defn{\emph{Unsafe execution}: $\omega \lbb \alpha\rbb \lightning$ means executing $\alpha$ starting in state $\omega$ performs an unsafe operation.}
  \item \defn{\emph{Safe program (at $\omega$)}: not unsafe, i.e. \textbf{not} $\omega \lbb \alpha\rbb \lightning$ (it may still diverge).}
  \item \defn{\emph{Indeterminate behavior}: execution is safe, but some expression results are unspecified; we keep expressions safe and push “badness” into commands.}
  \item \defn{\emph{Updated box semantics (partial correctness + safety)}:}
    \[
      \omega \models [\alpha]Q
      \ \mbox{iff}\
      \Big(\forall\nu.\; (\omega \lbb\alpha\rbb \nu \Rightarrow \nu\models Q)\Big)
      \ \land\
      \textbf{not}\ (\omega \lbb \alpha\rbb \lightning).
    \]
\end{itemize}

\subsection*{Key rules / recipes}
\begin{itemize}[leftmargin=*]
  \item \idea{To prove safety: aim for $P \arrow [\alpha]\top$ and then rely on rules that force you to prove the operation-specific safety condition.}
  \item \idea{Unsafe command example (division-as-command): $x := \mb{divide}\; e_1\; e_2$ is unsafe when $e_2$ evaluates to $0$.}
  \item \idea{Sequent rule shape for unsafe commands: one premise proves the safety side-condition, another carries the (possibly indeterminate) result into a fresh post-state variable.}
\end{itemize}

\subsection*{Two “control” commands: \texttt{assert} vs \texttt{test}}
\begin{itemize}[leftmargin=*]
  \item \kw{Assertion:} $\mb{assert}\; P$ is unsafe when $P$ is false (like “crash = unsafe”).
    \\[0.25em]
    \idea{Axiom: $[\mb{assert}\; P]Q \leftrightarrow (P \land Q)$.}
  \item \kw{Guard/test:} $\mb{test}\; P$ aborts safely when $P$ is false (no poststate, but \emph{not} unsafe).
    \\[0.25em]
    \idea{Axiom: $[\mb{test}\; P]Q \leftrightarrow (P \arrow Q)$.}
\end{itemize}

\subsection*{Sandboxing recipe}
\begin{itemize}[leftmargin=*]
  \item \kw{Transform:} before any potentially unsafe command $c$, insert a guard $\mb{test}\; \ms{Safe}(c)$.
  \item \idea{Why it works:} after $\mb{test}\; \ms{Safe}(c)$, you can use the guard postcondition to discharge the safety premise required by the unsafe-command rule.
\end{itemize}

\subsection*{Pitfalls}
\begin{itemize}[leftmargin=*]
  \item \pitfall{Nontermination is \emph{not} the same as unsafe: $[\alpha]Q$ can still hold vacuously when $\alpha$ diverges, but it must be false if $\alpha$ is unsafe.}
  \item \pitfall{Mixing up $\mb{assert}\; P$ and $\mb{test}\; P$: the former is unsafe on failure; the latter aborts safely on failure.}
\end{itemize}

\subsection*{Check yourself}
\begin{enumerate}[leftmargin=*]
  \item \q{Why is $[\mb{test}\; \bot]Q$ valid for every $Q$ under the updated box semantics?}
  \item \q{What formula do you prove to show “division by $e_2$ is safe” inside a proof of $P \arrow [\alpha]\top$?}
\end{enumerate}

\clearpage
\section*{Lecture 6 (Jan 27, 2026): Memory Safety}
\kw{Goal:} Add a (bounded) memory model, define unsafe out-of-bounds reads/writes, and learn proof patterns for memory safety (often invariants with bounds + optional sandboxing via guards).

\subsection*{One-page map}
\begin{itemize}[leftmargin=*]
  \item \kw{Memory model:} a distinguished variable $M$ denotes a heap/array $H : \mathbb{Z}\to\mathbb{Z}$.
  \item \kw{Bounded addresses:} legal indices satisfy $0 \le i < \ms{U}$; out-of-bounds access is unsafe.
  \item \kw{New commands:} read $x := M[e]$ and write $M[e_1] := e_2$ (unsafe if the index is out of bounds).
  \item \kw{Reasoning support:} use theory-of-arrays style terms $\mb{read}\; M\; e$ and $\mb{write}\; M\; e_1\; e_2$ in \emph{formulas} (expressions remain safe but may be indeterminate).
\end{itemize}

\subsection*{Core definitions}
\begin{itemize}[leftmargin=*]
  \item \defn{\emph{Safe read}: $x := M[e]$ is safe iff $0 \le e < \ms{U}$.}
  \item \defn{\emph{Safe write}: $M[e_1] := e_2$ is safe iff $0 \le e_1 < \ms{U}$.}
  \item \defn{\emph{State shape}: lowercase variables map to integers; uppercase variables like $M$ map to heaps/arrays.}
\end{itemize}

\subsection*{Key rules (as recipes)}
\begin{itemize}[leftmargin=*]
  \item \idea{Read rule forces a bounds proof \emph{and} introduces a fresh post-state variable:}
    \\[0.25em]
    $\Gamma \vdash [x := M[e]]Q(x),\Delta$ reduces to
    $\Gamma \vdash 0 \le e < \ms{U},\Delta$ and $\Gamma, x' = \mb{read}\; M\; e \vdash Q(x'),\Delta$.
  \item \idea{Write is analogous with fresh $M'$:}
    \\[0.25em]
    $\Gamma \vdash [M[e_1] := e_2]Q(M),\Delta$ reduces to
    $\Gamma \vdash 0 \le e_1 < \ms{U},\Delta$ and $\Gamma, M' = \mb{write}\; M\; e_1\; e_2 \vdash Q(M'),\Delta$.
  \item \idea{Invariant pattern: to keep writes safe in loops, invariants usually need both a lower bound and the global $\ms{U}$ bound (e.g. $0 \le i \le n < \ms{U}$).}
\end{itemize}

\subsection*{Tiny example (invariant needs bounds)}
\begin{itemize}[leftmargin=*]
  \item \kw{Program:} $i := 0;\;\mb{while}\ (i<n)\ \{M[i]:=i;\; i:=i+1\}$.
  \item \idea{To prove $0 \le n < \ms{U} \arrow [\cdots]\top$, a good invariant is $0 \le i \le n < \ms{U}$ (not just $i\le n$).}
\end{itemize}

\subsection*{Sandboxing memory access}
\begin{itemize}[leftmargin=*]
  \item \idea{Instrument reads/writes:}
    \begin{itemize}[leftmargin=*]
      \item replace $x := M[e]$ by $\mb{test}\; 0 \le e < \ms{U} \semi x := M[e]$;
      \item replace $M[e_1] := e_2$ by $\mb{test}\; 0 \le e_1 < \ms{U} \semi M[e_1] := e_2$.
    \end{itemize}
  \item \idea{Result:} the sandboxed program is provably safe (often with invariant $\top$), but may abort.
\end{itemize}

\subsection*{Pitfalls}
\begin{itemize}[leftmargin=*]
  \item \pitfall{For loop preservation, you drop the initial-context assumptions $\Gamma$; invariants must carry the needed bounds themselves.}
  \item \pitfall{After a write you must reason about the new heap $M'$ (freshness), not the old $M$.}
\end{itemize}

\subsection*{Check yourself}
\begin{enumerate}[leftmargin=*]
  \item \q{Why does the invariant $i\le n$ fail to prove safety for $M[i] := i$ inside the loop body? Name the missing facts.}
  \item \q{Write the sandboxed version of $x := M[y+1]$ and explain (briefly) what property it guarantees.}
\end{enumerate}

\clearpage
\section*{Lecture 7 (Feb 1, 2026): Generating Verification Conditions}
\kw{Goal:} Compute a weakest liberal precondition (WLP) function $\ms{wlp}\;\alpha\;Q$ so that proving $P \arrow [\alpha]Q$ reduces to proving a \emph{pure arithmetic} formula $P \arrow \ms{wlp}\;\alpha\;Q$ (verification condition generation).

\subsection*{One-page map}
\begin{itemize}[leftmargin=*]
  \item \kw{Problem:} DL formulas mix programs and logic; arithmetic provers only handle \emph{pure} formulas.
  \item \kw{Solution:} translate $[\alpha]Q$ into a pure formula $\ms{wlp}\;\alpha\;Q$.
  \item \kw{VCG pipeline:} show validity of $P \arrow \ms{wlp}\;\alpha\;Q$ using an arithmetic solver.
  \item \kw{Loops:} true WLP needs invariants; compute WLP \emph{relative to} supplied loop invariants.
\end{itemize}

\subsection*{Core definitions}
\begin{itemize}[leftmargin=*]
  \item \defn{\emph{Sufficient precondition}: $P$ is sufficient for $\alpha,Q$ if $P \arrow [\alpha]Q$ is valid.}
  \item \defn{\emph{Weakest liberal precondition}: $\ms{wlp}\;\alpha\;Q$ is a pure $P$ such that (1) $P \arrow [\alpha]Q$ and (2) any other sufficient $P'$ implies $P$.}
  \item \defn{\emph{Verification condition}: $P \arrow \ms{wlp}\;\alpha\;Q$ (pure).}
\end{itemize}

\subsection*{WLP recipes (loop-free, high level)}
\begin{itemize}[leftmargin=*]
  \item \idea{\kw{Sequence:} $\ms{wlp}\;(\alpha \semi \beta)\;Q \;=\; \ms{wlp}\;\alpha\;(\ms{wlp}\;\beta\;Q)$ (work right-to-left).}
  \item \idea{\kw{Assignment:} for pure $Q(x)$, WLP is substitution: $\ms{wlp}\;(x:=e)\;Q(x)=Q(e)$.}
  \item \idea{\kw{If:} split by the guard: WLP becomes a conjunction of implications (``both branches correct under their path condition'').}
\end{itemize}

\subsection*{Loops (invariant-based)}
\begin{itemize}[leftmargin=*]
  \item \idea{To handle $\mb{while}\;P\;\alpha$, require an invariant $J$ and generate obligations: init ($P_0 \arrow J$), preservation ($J \land P \arrow [\alpha]J$), and post ($J \land \lnot P \arrow Q$).}
  \item \pitfall{If you forget needed facts in $J$, preservation fails because the initial-context assumptions are not available inside the loop.}
\end{itemize}

\subsection*{Check yourself}
\begin{enumerate}[leftmargin=*]
  \item \q{Why must $\ms{wlp}\;\alpha\;Q$ be a \emph{pure} formula to be useful for automation?}
  \item \q{Compute $\ms{wlp}\;(x:=x+1)\;(x \ge 0)$.}
\end{enumerate}

\clearpage
\section*{Lecture 8 (Feb 3, 2026): Symbolic Evaluation}
\kw{Goal:} Model program reasoning via control-flow graphs and \emph{path formulas}; detect potential assertion/safety violations by checking satisfiability of path conditions.

\subsection*{One-page map}
\begin{itemize}[leftmargin=*]
  \item \kw{CFG view:} nodes are program points; edges are possible transitions annotated with ``information gained''.
  \item \kw{Paths:} each path corresponds to one branch of symbolic execution / proof search.
  \item \kw{Path formula:} conjunction of branch conditions plus equalities from assignments (often via fresh primed variables).
  \item \kw{Bug finding:} characterize paths leading to an unsafe state (e.g. assertion failure) and ask if their path formulas are satisfiable.
\end{itemize}

\subsection*{Core definitions}
\begin{itemize}[leftmargin=*]
  \item \defn{\emph{Control flow graph (CFG)}: directed graph of program points with edges for possible control transfers.}
  \item \defn{\emph{Path formula}: conjunction of edge labels along a path, including renamed assignment facts (e.g. $x' = e$).}
  \item \defn{\emph{Feasible path}: a path whose path formula is satisfiable.}
\end{itemize}

\subsection*{Key recipes}
\begin{itemize}[leftmargin=*]
  \item \idea{\kw{Renaming:} treat each assignment as introducing a fresh ``post'' variable (SSA-like) to keep constraints purely logical.}
  \item \idea{\kw{Infeasible path pruning:} if the path formula contains a contradiction (e.g. $x\ge 0$ and $\lnot(x\ge 0)$), stop exploring that path.}
  \item \idea{\kw{Assertion failure search:} negate the assertion condition at the failure node and check satisfiability to find a counterexample trace.}
\end{itemize}

\subsection*{Pitfalls}
\begin{itemize}[leftmargin=*]
  \item \pitfall{Forgetting renaming makes constraints unsound (mixes pre- and post-assignment values).}
  \item \pitfall{Path explosion: number of paths can be exponential in program size; pruning/invariants are essential.}
\end{itemize}

\subsection*{Check yourself}
\begin{enumerate}[leftmargin=*]
  \item \q{What does it mean if an ``unsafe'' path formula is satisfiable?}
  \item \q{Why can you discard any path whose formula is unsatisfiable without losing bugs?}
\end{enumerate}

\clearpage
\section*{Lecture 9 (Feb 8, 2026): Program Analysis}
\kw{Goal:} Connect the lecture algorithms to implementable analyses: (1) evaluation with \emph{partial} states, and (2) a def/use analysis to ensure variables are defined before use.

\subsection*{One-page map}
\begin{itemize}[leftmargin=*]
  \item \kw{Issue:} the mathematical semantics treats states as total maps; real interpreters may face undefined variables.
  \item \kw{Evaluation:} define evaluators for expressions ($\evalz$), booleans ($\evalb$), and programs ($\eval$).
  \item \kw{Static check:} def/use analysis computes which variables a program may use and must define.
  \item \kw{Guarantee:} if all uses are defined-before-use, evaluation won't get stuck on missing variables.
\end{itemize}

\subsection*{Core definitions}
\begin{itemize}[leftmargin=*]
  \item \defn{\emph{Partial state}: a partial map from variables to integers; $\omega(x)$ may be undefined.}
  \item \defn{\emph{Use set} $\ms{use}\;\alpha$: variables that $\alpha$ \emph{may} read.}
  \item \defn{\emph{Def set} $\ms{def}\;\alpha$: variables that $\alpha$ \emph{must} define (on all terminating paths).}
\end{itemize}

\subsection*{Key recipes}
\begin{itemize}[leftmargin=*]
  \item \idea{\kw{Evaluation for sequence:} evaluate $\alpha$ then $\beta$ in the resulting state (account for ``no poststate'' outcomes like failed tests).}
  \item \idea{\kw{Def/use for conditionals:} $\ms{use}$ is a may-property (union over branches), while $\ms{def}$ is a must-property (intersection over branches).}
  \item \idea{\kw{Def/use for assignment:} $\ms{def}(x:=e)=\{x\}$ and $\ms{use}(x:=e)=\ms{use}(e)$.}
\end{itemize}

\subsection*{Pitfalls}
\begin{itemize}[leftmargin=*]
  \item \pitfall{Treating $\ms{def}$ as ``may define'' leads to unsoundness: a variable might be undefined on some path.}
  \item \pitfall{Not accounting for abort/no-poststate behavior (e.g. tests) when implementing $\eval$.}
\end{itemize}

\subsection*{Check yourself}
\begin{enumerate}[leftmargin=*]
  \item \q{Why is $\ms{def}$ for an \texttt{if} the \emph{intersection} of the branch def-sets?}
  \item \q{Give a 3-line program where a variable is used before it is defined on some path.}
\end{enumerate}

\clearpage
\section*{Appendices}
\noindent\rule{\linewidth}{0.6pt}

\appendix


\section{Propositional sequent calculus (full rule list)}
\label{app:prop-sequent}
\kw{Sequents:} $\Gamma \vdash \Delta$ where $\Gamma,\Delta$ are (multi)sets of formulas.
\kw{Validity:} all $\Gamma$ true implies some $\Delta$ true.

\subsection*{Identity}
\begin{rules}
  \infer[\ms{id}]
  {\Gamma, F \vdash F, \Delta}
  {}
\end{rules}

\subsection*{Logical connectives}

% Compact, aligned grid (Name | Right rule | Left rule)
\begingroup
\setlength{\inferLineSkip}{1pt}
\[
  \begin{array}{l@{\hspace{1.2em}}c@{\hspace{2.2em}}c}
    \textbf{True}
    & \infer[{\top}R]{\Gamma \vdash \top, \Delta}{}
    & \infer[{\top}L]{\Gamma, \top \vdash \Delta}{\Gamma \vdash \Delta}
    \\[0.35em]

    \textbf{False}
    & \infer[{\bot}R]{\Gamma \vdash \bot, \Delta}{\Gamma \vdash \Delta}
    & \infer[{\bot}L]{\Gamma, \bot \vdash \Delta}{}
    \\[0.55em]

    \textbf{Negation}
    & \infer[{\lnot}R]{\Gamma \vdash \lnot F, \Delta}{\Gamma, F \vdash \Delta}
    & \infer[{\lnot}L]{\Gamma, \lnot F \vdash \Delta}{\Gamma \vdash F, \Delta}
    \\[0.55em]

    \textbf{Conjunction}
    & \infer[{\land}R]{\Gamma \vdash F \land G, \Delta}{\Gamma \vdash F, \Delta & \Gamma \vdash G, \Delta}
    & \infer[{\land}L]{\Gamma, F \land G \vdash \Delta}{\Gamma, F, G \vdash \Delta}
    \\[0.55em]

    \textbf{Disjunction}
    & \infer[{\lor}R]{\Gamma \vdash F \lor G, \Delta}{\Gamma \vdash F, G, \Delta}
    & \infer[{\lor}L]{\Gamma, F \lor G \vdash \Delta}{\Gamma, F \vdash \Delta & \Gamma, G \vdash \Delta}
    \\[0.55em]

    \textbf{Implication}
    & \infer[{\arrow}R]{\Gamma \vdash F \arrow G, \Delta}{\Gamma, F \vdash G, \Delta}
    & \infer[{\arrow}L]{\Gamma, F \arrow G \vdash \Delta}{\Gamma \vdash F, \Delta & \Gamma, G \vdash \Delta}
    \\[0.55em]

    \textbf{NOR ($\downarrow$)}
    & \infer[{\downarrow}R]{\Gamma \vdash F \downarrow G, \Delta}{\Gamma, F \vdash \Delta & \Gamma, G \vdash \Delta}
    & \infer[{\downarrow}L]{\Gamma, F \downarrow G \vdash \Delta}{\Gamma \vdash F, G, \Delta}
  \end{array}
\]
\endgroup

\section{Dynamic logic: Language summary (incl.~safety + memory)}
\label{app:dl-language}
\vspace{-1\baselineskip}
\[
  \begin{array}{llcl}
    \mbox{Int vars} & x, y, z \\
    \mbox{Memory var} & M \\
    \mbox{Constants} & c & ::= & \ldots, -1, 0, 1, \ldots \\
    \mbox{Expressions} & e & ::= & c \mid x \mid e_1 + e_2 \mid e_1 * e_2 \mid e_1 - e_2 \mid \ldots \\
                     & & \mid  & e_1 / e_2 \mid \mb{read}\; M\; e \mid \mb{write}\; M\; e_1\; e_2 \\
    \mbox{Programs} & \alpha, \beta & ::= & x := e \mid \mb{skip} \mid \alpha \semi \beta
                                            \mid \mb{if}\; P\; \mb{then}\; \alpha\; \mb{else}\; \beta
                                            \mid \mb{while}\; P\; \alpha \\
                     & & \mid & \mb{test}\; P \mid \mb{assert}\; P \\
                     & & \mid & x := \mb{divide}\; e_1\; e_2 \\
                     & & \mid & x := M[e] \mid M[e_1] := e_2 \\
    \mbox{Formulas} & P, Q & ::= & e_1 \leq e_2 \mid e_1 = e_2 \mid \top \mid \bot \\
                     & & \mid  & P \land Q \mid P \lor Q \mid P \arrow Q \mid P \leftrightarrow Q \mid \lnot P \\
                     & & \mid & [\alpha]Q \mid \langle \alpha\rangle Q
  \end{array}
\]

\section{Dynamic logic: rule summary (box modality)}
\label{app:dl-rules}
\kw{Reading:} $[\alpha]Q$ is partial correctness (all \emph{terminating} runs end in $Q$).

\begin{rules}
  \infer[{[\mb{if}]}R]
  {\Gamma \vdash [\mb{if}\; P\; \mb{then}\; \alpha\; \mb{else}\; \beta]Q, \Delta}
  {\Gamma, P \vdash [\alpha]Q, \Delta
    & \Gamma, \lnot P \vdash [\beta]Q, \Delta}

  \\[1em]
  \infer[{[\mb{:=}]}R^{x'}]
  {\Gamma \vdash [x := e]Q(x), \Delta}
  {\Gamma, x' = e \vdash Q(x'), \Delta}

  \\[1em]
  \infer[{[\semi]}R]
  {\Gamma \vdash [\alpha \semi \beta]Q, \Delta}
  {\Gamma \vdash [\alpha]([\beta]Q), \Delta}

  \\[1em]
  \infer[{[\mb{unfold}]}R]
  {\Gamma \vdash [\mb{while}\; P\; \alpha]Q, \Delta}
  {\Gamma, P \vdash [\alpha]([\mb{while}\; P\; \alpha]Q), \Delta
    & \Gamma, \lnot P \vdash Q, \Delta}

  \\[1em]
  \infer[{[\mb{while}]}R]
  {\Gamma \vdash [\mb{while}_J\; P\; \alpha]Q, \Delta}
  {\Gamma \vdash J, \Delta
    & J, P \vdash [\alpha]J
    & J, \lnot P \vdash Q}
\end{rules}

\begingroup
\setlength{\parskip}{0.2\baselineskip}
\setlength{\abovedisplayskip}{2pt}
\setlength{\belowdisplayskip}{2pt}
\setlength{\abovedisplayshortskip}{1pt}
\setlength{\belowdisplayshortskip}{1pt}
\setlength{\inferLineSkip}{1pt}
\renewcommand{\arraystretch}{0.52}

\section{Semantics cheat sheet}
\label{app:semantics}
\kw{States:} total maps $\omega$ that map int variables to $\mathbb{Z}$ and memory variables (like $M$) to heaps $H : \mathbb{Z}\to\mathbb{Z}$.

\paragraph{Unsafe execution}
\[
  \omega \lbb \alpha\rbb \lightning
\]
means executing $\alpha$ from $\omega$ performs an unsafe operation (so it has no poststate).

\paragraph{Expressions}
\[
  \omega \lbb c\rbb = c
  \qquad
  \omega \lbb x\rbb = \omega(x)
  \qquad
  \omega \lbb e_1 + e_2\rbb = \omega \lbb e_1\rbb + \omega \lbb e_2\rbb
\]
(and similarly for other operators).

\paragraph{State update}
\[
  (\omega[x \mapsto c])(x)=c
  \qquad
  (\omega[x \mapsto c])(y)=\omega(y)\ \mbox{for } y\neq x
\]

\paragraph{Programs as relations}
Write $\omega \lbb \alpha\rbb \nu$ for ``executing $\alpha$ can take prestate $\omega$ to poststate $\nu$''.
\[
  \omega \lbb x := e\rbb \nu \ \mbox{iff}\ \nu = \omega[x \mapsto \omega \lbb e\rbb]
\]
\[
  \omega \lbb \alpha \semi \beta\rbb \nu \ \mbox{iff}\ \exists\mu.\ \omega \lbb\alpha\rbb \mu \land \mu \lbb\beta\rbb \nu
\]
\[
  \omega \lbb \mb{if}\; P\; \mb{then}\; \alpha\; \mb{else}\; \beta\rbb \nu
  \ \mbox{iff}\
  (\omega\models P \land \omega \lbb\alpha\rbb \nu)\ \mbox{or}\ (\omega\not\models P \land \omega \lbb\beta\rbb \nu)
\]
\[
  \omega \lbb \mb{while}\; P\; \alpha\rbb \nu \ \mbox{iff}\ \omega \lbb \mb{while}\; P\; \alpha\rbb^n\nu\ \mbox{for some } n\in\mathbb{N}
\]
with the bounded-iteration clauses:
\[
  \omega \lbb \mb{while}\; P\; \alpha\rbb^{0}\nu \ \mbox{iff}\ (\omega\not\models P \land \omega=\nu)
\]
\[
  \omega \lbb \mb{while}\; P\; \alpha\rbb^{n+1}\nu \ \mbox{iff}\ (\omega\models P \land \exists\mu.\ \omega \lbb\alpha\rbb \mu \land \mu \lbb \mb{while}\; P\; \alpha\rbb^{n}\nu)
\]

\paragraph{Formulas}
\[
  \omega\models [\alpha]Q
  \ \mbox{iff}\
  \Big(\forall\nu.\ (\omega \lbb\alpha\rbb \nu \Rightarrow \nu\models Q)\Big)
  \ \land\ \textbf{not}\ (\omega \lbb \alpha\rbb \lightning)
\]
\[
  \omega\models \langle\alpha\rangle Q \ \mbox{iff}\ \exists\nu.\ (\omega \lbb\alpha\rbb \nu \land \nu\models Q)
\]

\endgroup


\section{VCGen + symbolic evaluation + analysis (cheat sheet)}
\label{app:vcgen-symeval-analysis}

\subsection*{Pure formulas and Hoare triples}
\kw{Hoare triple:} $\{P\}\,\alpha\,\{Q\}$ abbreviates $P \arrow [\alpha]Q$ where $P,Q$ are \emph{pure} arithmetic formulas (no program modalities).

\subsection*{Weakest liberal precondition (WLP)}
\begin{itemize}[leftmargin=*]
  \item \kw{Goal:} compute a pure formula $\ms{wlp}\;\alpha\;Q$ such that proving $P \arrow [\alpha]Q$ reduces to proving $P \arrow \ms{wlp}\;\alpha\;Q$.
  \item \kw{VC:} $P \arrow \ms{wlp}\;\alpha\;Q$.
  \item \kw{Sequence:} $\ms{wlp}\;(\alpha \semi \beta)\;Q = \ms{wlp}\;\alpha\;(\ms{wlp}\;\beta\;Q)$.
  \item \kw{Assignment (pure $Q$):} $\ms{wlp}\;(x:=e)\;Q(x)=Q(e)$.
  \item \kw{Loops:} require invariant $J$; generate init/preserve/post obligations.
\end{itemize}

\subsection*{Symbolic evaluation (path formulas)}
\begin{itemize}[leftmargin=*]
  \item \kw{Path formula:} conjunction of branch conditions plus equalities from assignments (often with fresh $x'$ variables).
  \item \kw{Infeasible path:} path formula unsatisfiable $\Rightarrow$ no concrete execution follows it.
  \item \kw{Bug finding:} assertion-failure node + satisfiable path formula $\Rightarrow$ reachable counterexample trace exists.
\end{itemize}

\subsection*{Evaluation with partial states + def/use}
\begin{itemize}[leftmargin=*]
  \item \kw{Partial state:} $\omega(x)$ may be undefined; evaluation should not read undefined variables.
  \item \kw{$\ms{use}\;\alpha$:} variables $\alpha$ may read (union across branches).
  \item \kw{$\ms{def}\;\alpha$:} variables $\alpha$ must define (intersection across branches).
\end{itemize}

\end{document}
